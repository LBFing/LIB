

#include "var_type.h"
#include "logger.h"
#include "signal_catch.h"
#include "share_memory.h"
#include "redis_command.h"
#include "string_tool.h"
#include "blocking_queue.h"
#include "buffer_ex.h"




void TestMysqlPool()
{
	MysqlPool obj(111);
	string str = "mysql://root:123456@127.0.0.1:3306/LBF";
	bool bRet = obj.PutUrl(str.c_str(), 1);
	if(bRet)
	{
		cout << "mysql init success" << endl;
	}

	AutoHandle handle(&obj, 1);
	if(!handle())
	{
		printf("不能从数据库连接池获取连接句柄\n");
		return ;
	}

	string strSql = "select * from SERVERLIST";
	DataSet* ret_set = handle()->ExeSelect(strSql.c_str(), strSql.length());

	if(!ret_set || ret_set->Size() == 0)
	{
		delete ret_set;
		ret_set = NULL;
		printf("数据库中的记录为空\n");

		return;
	}

	for(uint32 i = 0 ; i < ret_set->Size() ; i++)
	{
		int a1 = ret_set->GetValue(i, "ID");
		int a2 = ret_set->GetValue(i, "TYPE");
		int a3 = ret_set->GetValue(i, "DYNAMIC");
		const char* b1 = ret_set->GetValue(i, "NAME");
		const char* b2 = ret_set->GetValue(i, "IP");
		int a4 = ret_set->GetValue(i, "PORT");
		const char* b3 = ret_set->GetValue(i, "EXTIP");
		int a5 = ret_set->GetValue(i, "EXTPORT");
		int a6 = ret_set->GetValue(i, "NETTYPE");
		printf("%d\t%d\t%d\t%s\t%s\t%d\t%s\t%d\t%d\n", a1, a2, a3, b1, b2, a4, b3, a5, a6);
	}

}


void TestVarType()
{
	uint32 nRow = 7;
	uint32 nField = 5;
	char szName[10] = {0};

	DataSet* ret_set = new DataSet(nRow, nField);
	if(ret_set == NULL)
	{
		printf("error dataset new\n");
	}

	for(uint32 i = 0 ; i < nField; i++)
	{
		sprintf(szName, "Field%d", i);
		if(ret_set->PutField(i, szName) == false)
		{
			printf("error PutField\n");
			return;
		}
	}


	// IterFeild iter1 = ret_set->m_field_set.begin();
	// IterFeild iter2 = ret_set->m_field_set.end();
	// while(iter1  != iter2)
	// {
	// 	cout << (*iter1).nIndex << ":" << (*iter1).szName << endl;
	// 	iter1++;
	//}
	//cout << ret_set->m_field_set.size() << " " << ret_set->m_record.Size() << endl;

	for(uint32 i = 0 ; i < nRow; i++)
	{
		for(uint32 j = 0 ; j < nField; j++)
		{
			sprintf(szName, "value_%d_%d", i, j);
			ret_set->PutValue(i, j, szName, strlen(szName) + 1);
		}
	}

	for(uint32 i = 0 ; i < nRow; i++)
	{
		const char* value = ret_set->GetValue(i, "Field1");
		//cout << "Field1:" << value << endl;
		DEBUG("Field1:%s", value);
		INFO("Field1:%s", value);
		WARN("Field1:%s", value);
		ERROR("Field1:%s", value);
	}
}

void TestSigal()
{
	SetSignedCatched();
}

struct SharedST
{
	SharedST()
	{
		memset(this, 0, sizeof(SharedST));
	}
	uint32 id;
	uint32 num;
	char name[20];
};


void TestShareMemeory()
{
	SharedMemoryManager::newInstance();
	SharedMemoryManager::getInstance().allSharedMemory("shared.data");
	for (uint32 i = 1 ; i <= 20; i++)
	{
		SharedST* pTemp = new SharedST();
		if(pTemp)
		{
			pTemp->id = i;
			pTemp->num = 100 * i;
			sprintf(pTemp->name, "name_%d", i);
			SharedMemoryManager::getInstance().allocSharedMemory(i, pTemp, sizeof(SharedST));
			delete pTemp;
		}
	}
	struct SharedMemCB : public Callback<SharedST>
	{
		SharedMemCB() { count = 0 ;}
		bool exec(SharedST* pShared)
		{
			if (pShared == NULL)
			{
				return false;
			}

			DEBUG("Id:%d	Num:%d	Name:%s", pShared->id, pShared->num, pShared->name);
			count++;
			return true;
		}
		uint32 count;
	};

	SharedMemCB cb;
	SharedMemoryManager::getInstance().execEveryEntry(cb);
	INFO("SharedMemory Count:%d", cb.count);

	bool isExist = false;
	SharedST* pShared = (SharedST*)SharedMemoryManager::getInstance().setSharedMemory(15, isExist);
	INFO("Id:%d	Num:%d	Name:%s", pShared->id, pShared->num, pShared->name);

	SharedMemoryManager::delInstance();
}

void TestRedisCommand()
{
	Redis* r = new Redis();
	if(!r->connect("127.0.0.1", 6379))
	{
		ERROR("redis connect error!");
		return;
	}
	INFO("redis connect success!");
	r->set("name", "Mayuyu");
	DEBUG("Redis name:%s", r->get("name").c_str());
	delete r;
}

void TestBlockQueue()
{
	BlockingQueue<std::string> queue;
	for(int32 i = 0; i < 1000 ; i++)
	{
		string strTmp = StringTool::Format("%d",i);
		queue.put(strTmp);
	}

	INFO("queue size:%lu",queue.size());
	for (int32 i = 0 ; i < 10; i++)
	{
		string strTmp = queue.take();
		DEBUG("queue: %s",strTmp.c_str());
	}
	INFO("queue size:%lu",queue.size());
}



__thread uint32 seedp;

int main(int argc, char const* argv[])
{
	seedp = (uint32)time(NULL);
	InitLogger("/root/study/LIB/log/test.log", "DEBUG");
	//TestXMLParse();
	//TestJson();
	//TestMessage();
	//TestRegex();
	//TestVarType();
	//TestMysqlPool();
	//TestSigal();
	//usleep(SECOND);
	//for(int32 i = 0 ; i < 100; i++ )
	//{
	//	int32 abc = randBetween(1, 100);
	//	DEBUG("rand :%d", abc);
	//}
	//DEBUG("over!");
	//TestShareMemeory();
	//usleep(SECOND * 100);
	//TestRedisCommand();

	TestBlockQueue();
	return 0;
}
